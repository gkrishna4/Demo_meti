pipeline {
    agent {
        node {
            // Any Streaming 11.x and node compatible linux.
            label "((o.almalinux8 || o.rh8)) && c.docker-compatible-linux-3.10 && c.aws-cli-2 && c.docker-multi-stage-build && c.docker-20-compatible && q.str"
        }
    }
    
    options {
        buildDiscarder(logRotator(daysToKeepStr: '7', numToKeepStr: '3'))
        timeout(time: 3, unit: 'HOURS')
        skipDefaultCheckout()
    }

    triggers {
        pollSCM('H 7,14,20 * * 1-5')
    }
    
    parameters {
        choice(
            name: 'deployArtifacts',
            choices: ['default', 'never', 'always'],
            description: 'By default, only main and release-work branches are deployed. Some deployments can be skipped if there are no changes in the default case.'
        )

        string(
            name: 'mavenExtras',
            defaultValue: '',
            description: 'Extra JVM options for Maven, usually -DskipTests and the like.'
        )

        booleanParam(
            name: 'cleanWorkspace',
            defaultValue: true,
            description: 'Clean workspace before build.'
        )

        string(
            name: 'notificationEmail',
            defaultValue: 'when:team:tcds-dev@tibco.com change-authors',
            description: 'Email addresses for notifications on failure.'
        )

        string(
            name: 'successEmail',
            defaultValue: 'when:release:tcds-dev@tibco.com when:release:sbase-release@tibco.com change-authors',
            description: 'Email addresses for notifications on success.'
        )

        choice(
            name: 'buildVerbose',
            choices: ['default', 'pipeline', 'tools'],
            description: 'Make build more verbose with pipeline and tool diagnostics.'
        )

        string(
            name: 'buildLabel',
            defaultValue: '',
            description: 'Jenkins build label override.'
        )
    }
    
    environment {
        // Define environment variables if needed
        SONARQUBE_URL = 'http://sonarqube-server:9000'
        MAVEN_HOME = tool 'Maven'
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        
        stage('Build') {
            steps {
                script {
                    def mavenHome = tool 'Maven'
                    def mavenCMD = "${mavenHome}/bin/mvn"
                    sh "${mavenCMD} clean install ${params.mavenExtras}"
                }
            }
        }
        
        stage('Code Quality Analysis') {
            steps {
                script {
                    withSonarQubeEnv('SonarQube Server') {
                        sh "mvn sonar:sonar -Dsonar.host.url=${env.SONARQUBE_URL}"
                    }
                }
            }
        }
    }
    
    post {
        always {
            junit '**/target/surefire-reports/TEST-*.xml'
            archiveArtifacts 'target/*.jar'
        }
        
        success {
            script {
                emailext (
                    subject: "Build Success: ${env.JOB_NAME} - ${env.BUILD_NUMBER}",
                    body: "Build successful! No issues found.",
                    to: "${params.successEmail}",
                    mimeType: 'text/html'
                )
            }
        }
        
        failure {
            script {
                emailext (
                    subject: "Build Failure: ${env.JOB_NAME} - ${env.BUILD_NUMBER}",
                    body: "Build failed! Please check the build logs for details.",
                    to: "${params.notificationEmail}",
                    mimeType: 'text/html'
                )
            }
        }
    }
}



Dockerfile

FROM ubuntu:20.04

RUN apt-get -y update
RUN useradd -d /home/jenkins -u 1001 -m -s /bin/bash jenkins
RUN apt-get -y update && apt-get install -y unzip wget curl net-tools git vim xz-utils docker.io
RUN apt-get -y update && DEBIAN_FRONTEND=noninteractive apt-get install -y openjdk-11-jdk
#ln -fs /usr/share/zoneinfo/America/New_York /etc/localtime
#RUN mkdir -p /var/lib
RUN wget https://services.gradle.org/distributions/gradle-6.9-bin.zip -O /opt/gradle.zip
RUN (cd /opt && unzip gradle.zip)
USER jenkins
ENV JAVA_HOME /usr/lib/jvm/java-11-openjdk-amd64
ENV PATH /usr/local/bin:/usr/bin:/bin:/opt/gradle-6.9/bin
WORKDIR /home/jenkins


========================================================================================================

pipeline {
  agent any

  parameters {
    choice(name: 'BUILD_PROFILE', choices: ['dev', 'qa', 'prod'], description: 'Maven/Deployment profile')
    string(name: 'APP_VERSION', defaultValue: '1.0.0', description: 'Version tag to build & publish')
    booleanParam(name: 'RUN_SONAR', defaultValue: false, description: 'Run SonarQube analysis?')
    booleanParam(name: 'PUSH_IMAGE', defaultValue: true, description: 'Push image to Artifactory?')
    booleanParam(name: 'TRIVY_SCAN', defaultValue: true, description: 'Run Trivy image scan before push?')
    booleanParam(name: 'XRAY_SCAN',  defaultValue: true, description: 'Run JFrog Xray build scan after push?')
    choice(name: 'TRIVY_FAIL_ON', choices: ['CRITICAL', 'HIGH,CRITICAL', 'MEDIUM,HIGH,CRITICAL'], description: 'Fail build on these severities')
    booleanParam(name: 'DEPLOY_TO_K8S', defaultValue: false, description: 'Deploy to Kubernetes? (non-prod without approval; prod with approval)')
  }

  environment {
    // --- SonarQube (optional) ---
    SONARQUBE_SERVER = 'SonarQube-Server'

    // --- Docker / Artifactory ---
    ARTIFACTORY_URL          = 'https://artifactory.example.com'   // <-- change
    ARTIFACTORY_REGISTRY     = 'artifactory.example.com'           // <-- change
    ARTIFACTORY_REPO_DOCKER  = 'docker-local'                      // <-- change
    DOCKER_REPO              = 'your-team/yourapp'                 // logical image name
    IMAGE_TAG                = "${APP_VERSION}"

    // --- JFrog build-info ---
    JFROG_CLI_BUILD_NAME     = 'yourapp-build'
    JFROG_CLI_BUILD_NUMBER   = "${env.BUILD_NUMBER}"

    // --- Kubernetes (deployment) ---
    K8S_CONTEXT   = 'your-kube-context'                            // <-- change
    K8S_NAMESPACE = 'default'
    K8S_DEPLOYMENT= 'yourapp-deployment'                           // <-- change

    // --- Email notifications ---
    EMAIL_TO   = 'devops-team@example.com, you@example.com'        // <-- change
    EMAIL_FROM = 'jenkins@example.com'                             // <-- change
  }

  triggers {
    pollSCM('H/10 * * * *')
  }

  options {
    buildDiscarder(logRotator(numToKeepStr: '20', artifactNumToKeepStr: '10'))
    ansiColor('xterm')
    timestamps()
    disableConcurrentBuilds()
  }

  tools {
    maven 'Maven-3.9'
    jdk 'Temurin-17'
  }

  stages {

    stage('Checkout the Code') {
      steps {
        checkout scm
      }
    }

    stage('Build & Test (Parallel)') {
      parallel {
        stage('Maven Build') {
          steps {
            sh """
              mvn -B -U -P ${params.BUILD_PROFILE} clean package -DskipTests=false
            """
          }
        }
        stage('Unit Tests') {
          steps {
            sh "mvn -B test"
          }
          post {
            always { junit '**/target/surefire-reports/*.xml' }
          }
        }
      }
    }

    stage('Static Code Quality (SonarQube)') {
      when { expression { return params.RUN_SONAR } }
      steps {
        withSonarQubeEnv("${SONARQUBE_SERVER}") {
          sh """
            mvn -B sonar:sonar \
              -Dsonar.projectKey=yourapp-${params.BUILD_PROFILE} \
              -Dsonar.projectVersion=${env.IMAGE_TAG}
          """
        }
      }
      post {
        success {
          script {
            try {
              timeout(time: 10, unit: 'MINUTES') {
                waitForQualityGate abortPipeline: true
              }
            } catch (err) {
              error "Quality gate failed/timed out: ${err}"
            }
          }
        }
      }
    }

    stage('Docker Build') {
      steps {
        sh """
          docker build \
            --build-arg APP_VERSION=${IMAGE_TAG} \
            -t ${DOCKER_REPO}:${IMAGE_TAG} .
          docker tag ${DOCKER_REPO}:${IMAGE_TAG} ${ARTIFACTORY_REGISTRY}/${DOCKER_REPO}:${IMAGE_TAG}
        """
      }
    }

    stage('Security Scan (Trivy - Image)') {
      when { expression { return params.TRIVY_SCAN } }
      steps {
        sh """
          docker run --rm \
            -v /var/run/docker.sock:/var/run/docker.sock \
            -v ${WORKSPACE}:/workspace \
            aquasec/trivy:latest image \
            --timeout 5m \
            --format sarif \
            --output /workspace/trivy-image.sarif \
            --severity ${params.TRIVY_FAIL_ON} \
            --exit-code 1 \
            ${ARTIFACTORY_REGISTRY}/${DOCKER_REPO}:${IMAGE_TAG}
        """
      }
      post {
        always {
          archiveArtifacts allowEmptyArchive: true, artifacts: 'trivy-image.sarif'
        }
      }
    }

    stage('JFrog: Configure CLI') {
      steps {
        withCredentials([usernamePassword(credentialsId: 'jfrog-artifactory', usernameVariable: 'JF_USER', passwordVariable: 'JF_PASS')]) {
          sh """
            # If jfrog CLI isn't preinstalled, uncomment bootstrap:
            # curl -fL https://getcli.jfrog.io | sh
            # mv jfrog /usr/local/bin/

            jfrog config add artifactory-server --interactive=false \\
              --url='${ARTIFACTORY_URL}' \\
              --user="$JF_USER" --password="$JF_PASS"
            jfrog config use artifactory-server
            jfrog rt ping
          """
        }
      }
    }

    stage('Push to Artifactory (Docker) + Publish Build Info') {
      when { expression { return params.PUSH_IMAGE } }
      steps {
        sh """
          jfrog rt docker-login ${ARTIFACTORY_REGISTRY}

          jfrog rt docker-push ${ARTIFACTORY_REGISTRY}/${DOCKER_REPO}:${IMAGE_TAG} ${ARTIFACTORY_REPO_DOCKER} \\
            --build-name ${JFROG_CLI_BUILD_NAME} --build-number ${JFROG_CLI_BUILD_NUMBER}

          jfrog rt build-collect-env ${JFROG_CLI_BUILD_NAME} ${JFROG_CLI_BUILD_NUMBER}
          jfrog rt build-add-git  ${JFROG_CLI_BUILD_NAME} ${JFROG_CLI_BUILD_NUMBER}
          jfrog rt build-publish  ${JFROG_CLI_BUILD_NAME} ${JFROG_CLI_BUILD_NUMBER}
        """
      }
    }

    stage('JFrog Xray Build Scan') {
      when { expression { return params.XRAY_SCAN && params.PUSH_IMAGE } }
      steps {
        sh """
          jfrog rt build-scan ${JFROG_CLI_BUILD_NAME} ${JFROG_CLI_BUILD_NUMBER} --fail=false --vuln
        """
      }
    }

    /* -------------------- Manual Approval for PROD only -------------------- */
    stage('Prod Approval') {
      when {
        allOf {
          expression { return params.DEPLOY_TO_K8S }
          expression { return params.BUILD_PROFILE == 'prod' }
        }
      }
      steps {
        timeout(time: 60, unit: 'MINUTES') {
          script {
            // Only users in "ops" group or specific users below can approve
            def gate = input(
              id: 'ProdApproval',
              message: "Approve PRODUCTION deployment of ${DOCKER_REPO}:${IMAGE_TAG}?",
              ok: 'Deploy',
              submitter: 'ops,rama.krishna.reddy,platform-admin',
              parameters: [
                string(name: 'CHANGE_TICKET', defaultValue: 'CHG-XXXX', description: 'Change ticket ID (e.g., CHG-12345)'),
                booleanParam(name: 'CONFIRM', defaultValue: false, description: 'Confirm deployment to PROD')
              ]
            )
            if (!gate.CONFIRM) {
              error "Production deployment not confirmed. Aborting."
            }
            env.CHANGE_TICKET = gate.CHANGE_TICKET as String
            echo "Approved PROD deploy. Change ticket: ${env.CHANGE_TICKET}"
          }
        }
      }
    }

    stage('Deploy to Kubernetes') {
      when {
        expression { return params.DEPLOY_TO_K8S }
      }
      steps {
        sh """
          kubectl config use-context ${K8S_CONTEXT}
          kubectl -n ${K8S_NAMESPACE} set image deployment/${K8S_DEPLOYMENT} \\
            ${K8S_DEPLOYMENT}=${ARTIFACTORY_REGISTRY}/${DOCKER_REPO}:${IMAGE_TAG}
          kubectl -n ${K8S_NAMESPACE} rollout status deployment/${K8S_DEPLOYMENT} --timeout=180s
        """
      }
    }
  }

  /* -------------------- Global Notifications -------------------- */
  post {
    success {
      emailext(
        subject: "SUCCESS: ${env.JOB_NAME} #${env.BUILD_NUMBER} (${params.BUILD_PROFILE})",
        to: "${EMAIL_TO}",
        from: "${EMAIL_FROM}",
        mimeType: 'text/html',
        body: """
        <h3>✅ Build Succeeded</h3>
        <p><b>Job:</b> ${env.JOB_NAME} #${env.BUILD_NUMBER}</p>
        <p><b>Profile:</b> ${params.BUILD_PROFILE}</p>
        <p><b>Image:</b> ${ARTIFACTORY_REGISTRY}/${DOCKER_REPO}:${IMAGE_TAG}</p>
        <p><a href="${env.BUILD_URL}console">View Console</a> | <a href="${env.BUILD_URL}artifact">Artifacts</a></p>
        """
      )
      // If email-ext not available, fallback:
      // mail to: "${EMAIL_TO}", subject: "SUCCESS: ${env.JOB_NAME} #${env.BUILD_NUMBER}", body: "Build success. ${env.BUILD_URL}"
    }
    failure {
      emailext(
        subject: "FAILED: ${env.JOB_NAME} #${env.BUILD_NUMBER} (${params.BUILD_PROFILE})",
        to: "${EMAIL_TO}",
        from: "${EMAIL_FROM}",
        mimeType: 'text/html',
        body: """
        <h3>❌ Build/Deployment Failed</h3>
        <p><b>Job:</b> ${env.JOB_NAME} #${env.BUILD_NUMBER}</p>
        <p><b>Profile:</b> ${params.BUILD_PROFILE}</p>
        <p><b>Last Stage likely failed:</b> Check console log.</p>
        <p><a href="${env.BUILD_URL}console">View Console</a></p>
        """
      )
    }
    aborted {
      emailext(
        subject: "ABORTED: ${env.JOB_NAME} #${env.BUILD_NUMBER} (${params.BUILD_PROFILE})",
        to: "${EMAIL_TO}",
        from: "${EMAIL_FROM}",
        mimeType: 'text/html',
        body: """
        <h3>⚠️ Build Aborted</h3>
        <p><b>Job:</b> ${env.JOB_NAME} #${env.BUILD_NUMBER}</p>
        <p><b>Profile:</b> ${params.BUILD_PROFILE}</p>
        <p>This often means the <b>PROD approval</b> was declined or timed out.</p>
        <p><a href="${env.BUILD_URL}console">View Console</a></p>
        """
      )
    }
    always {
      archiveArtifacts allowEmptyArchive: true, artifacts: '**/target/*.jar'
    }
  }
}
==========================================

GitHub Actions pipeline
-----------------------
name: CI-CD EKS with JFrog, Trivy, SonarQube, Manual Approval & Email

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      BUILD_PROFILE:
        description: "Build/Deployment profile"
        type: choice
        required: true
        options: [ "dev", "qa", "prod" ]
        default: "dev"
      APP_VERSION:
        description: "Version tag to build & publish"
        required: true
        default: "1.0.0"
      RUN_SONAR:
        description: "Run SonarQube analysis?"
        type: boolean
        default: false
      TRIVY_SCAN:
        description: "Run Trivy scan before push?"
        type: boolean
        default: true
      TRIVY_FAIL_ON:
        description: "Fail build on these severities"
        type: choice
        options: [ "CRITICAL", "HIGH,CRITICAL", "MEDIUM,HIGH,CRITICAL" ]
        default: "HIGH,CRITICAL"
      PUSH_IMAGE:
        description: "Push image to Artifactory?"
        type: boolean
        default: true
      XRAY_SCAN:
        description: "Run JFrog Xray build scan after push?"
        type: boolean
        default: true
      DEPLOY_TO_K8S:
        description: "Deploy to Kubernetes? (non-prod direct; prod needs approval)"
        type: boolean
        default: false

env:
  # App / Build
  DOCKER_REPO: your-team/yourapp
  IMAGE_TAG: ${{ inputs.APP_VERSION || '1.0.0' }}
  BUILD_PROFILE: ${{ inputs.BUILD_PROFILE || 'dev' }}

  # JFrog / Artifactory
  JFROG_BUILD_NAME: yourapp-build
  JFROG_BUILD_NUMBER: ${{ github.run_number }}
  ARTIFACTORY_REGISTRY: ${{ secrets.ARTIFACTORY_REGISTRY }}      # e.g., artifactory.example.com
  ARTIFACTORY_DOCKER_REPO: ${{ secrets.ARTIFACTORY_DOCKER_REPO }}# e.g., docker-local

  # Email
  MAIL_FROM: ${{ secrets.MAIL_FROM }}
  MAIL_TO:   ${{ secrets.MAIL_TO }}

  # Sonar
  SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}

  # Control flags (default when triggered by push/pr)
  RUN_SONAR:  ${{ inputs.RUN_SONAR || false }}
  TRIVY_SCAN: ${{ inputs.TRIVY_SCAN || true }}
  TRIVY_FAIL_ON: ${{ inputs.TRIVY_FAIL_ON || 'HIGH,CRITICAL' }}
  PUSH_IMAGE: ${{ inputs.PUSH_IMAGE || true }}
  XRAY_SCAN:  ${{ inputs.XRAY_SCAN || true }}
  DEPLOY_TO_K8S: ${{ inputs.DEPLOY_TO_K8S || false }}

permissions:
  contents: read
  id-token: write     # for AWS OIDC if assuming role
  actions: read

concurrency:
  group: yourapp-${{ github.ref }}-deploy
  cancel-in-progress: false

jobs:

  build-test:
    name: Build & Test (Maven)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"

      - name: Maven Build
        run: mvn -B -U -P "${BUILD_PROFILE}" clean package -DskipTests=false

      - name: Unit Tests
        run: mvn -B test

      - name: Archive surefire reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: surefire-reports
          path: "**/target/surefire-reports/*.xml"
          if-no-files-found: ignore

      - name: SonarQube Scan (optional)
        if: ${{ env.RUN_SONAR == 'true' }}
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          mvn -B sonar:sonar \
            -Dsonar.host.url="${SONAR_HOST_URL}" \
            -Dsonar.token="${SONAR_TOKEN}" \
            -Dsonar.projectKey=yourapp-${BUILD_PROFILE} \
            -Dsonar.projectVersion=${IMAGE_TAG}

  docker-and-scan:
    name: Docker Build + Trivy + Push + Build Info + Xray
    runs-on: ubuntu-latest
    needs: build-test
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build image (local)
        run: |
          docker build \
            --build-arg APP_VERSION=${IMAGE_TAG} \
            -t ${DOCKER_REPO}:${IMAGE_TAG} .
          docker tag ${DOCKER_REPO}:${IMAGE_TAG} ${ARTIFACTORY_REGISTRY}/${DOCKER_REPO}:${IMAGE_TAG}

      - name: Trivy Scan (pre-push)
        if: ${{ env.TRIVY_SCAN == 'true' }}
        uses: aquasecurity/trivy-action@0.22.0
        with:
          image-ref: "${{ env.ARTIFACTORY_REGISTRY }}/${{ env.DOCKER_REPO }}:${{ env.IMAGE_TAG }}"
          format: 'sarif'
          output: 'trivy-image.sarif'
          severity: "${{ env.TRIVY_FAIL_ON }}"
          exit-code: '1'    # fail build if matches severities
          timeout: '5m'
      - name: Upload Trivy SARIF
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-image-scan
          path: trivy-image.sarif
          if-no-files-found: ignore

      - name: Setup JFrog CLI
        uses: jfrog/setup-jfrog-cli@v4
        env:
          JF_URL: ${{ secrets.JFROG_URL }}
          JF_USER: ${{ secrets.JFROG_USERNAME }}
          JF_PASSWORD: ${{ secrets.JFROG_PASSWORD }}

      - name: Login Docker to Artifactory via JFrog CLI
        run: jfrog rt docker-login $ARTIFACTORY_REGISTRY

      - name: Push image to Artifactory (and capture build-info)
        if: ${{ env.PUSH_IMAGE == 'true' }}
        run: |
          jfrog rt docker-push ${ARTIFACTORY_REGISTRY}/${DOCKER_REPO}:${IMAGE_TAG} ${ARTIFACTORY_DOCKER_REPO} \
            --build-name ${JFROG_BUILD_NAME} --build-number ${JFROG_BUILD_NUMBER}
          jfrog rt build-collect-env ${JFROG_BUILD_NAME} ${JFROG_BUILD_NUMBER}
          jfrog rt build-add-git  ${JFROG_BUILD_NAME} ${JFROG_BUILD_NUMBER}
          jfrog rt build-publish  ${JFROG_BUILD_NAME} ${JFROG_BUILD_NUMBER}

      - name: Xray Scan (build-info)
        if: ${{ env.XRAY_SCAN == 'true' && env.PUSH_IMAGE == 'true' }}
        run: |
          # Set --fail=true after you tune Xray policies/watches to gate builds
          jfrog rt build-scan ${JFROG_BUILD_NAME} ${JFROG_BUILD_NUMBER} --fail=false --vuln

  prod-approval:
    name: Manual Approval (PROD)
    runs-on: ubuntu-latest
    needs: docker-and-scan
    if: ${{ env.DEPLOY_TO_K8S == 'true' && env.BUILD_PROFILE == 'prod' }}
    steps:
      - name: Wait for Approval (up to 60 minutes)
        uses: trstringer/manual-approval@v1
        with:
          secret: ${{ github.token }}
          approvers: "ops-team,rama-krishna-reddy,platform-admin"  # GitHub usernames
          minimum-approvals: 1
          issue-title: "PROD Deploy Approval: ${{ env.DOCKER_REPO }}:${{ env.IMAGE_TAG }}"
          issue-body: "Approve production deployment for change ticket? Provide CHG-ID in comment."
          timeout-minutes: 60
          exclude-workflow-initiator-as-approver: false

  deploy-nonprod:
    name: Deploy to K8s (non-PROD)
    runs-on: ubuntu-latest
    needs: docker-and-scan
    if: ${{ env.DEPLOY_TO_K8S == 'true' && env.BUILD_PROFILE != 'prod' }}
    steps:
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ secrets.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
      - name: Update kubeconfig (EKS)
        run: aws eks update-kubeconfig --name "${{ secrets.EKS_CLUSTER_NAME }}" --region "${{ secrets.AWS_REGION }}"
      - name: Rollout image
        run: |
          kubectl -n default set image deployment/yourapp-deployment \
            yourapp-deployment=${ARTIFACTORY_REGISTRY}/${DOCKER_REPO}:${IMAGE_TAG}
          kubectl -n default rollout status deployment/yourapp-deployment --timeout=180s

      # If NOT using EKS, comment above and use:
      # - name: Write kubeconfig from secret
      #   run: echo "${KUBECONFIG_B64}" | base64 -d > $HOME/.kube/config
      #   env:
      #     KUBECONFIG_B64: ${{ secrets.KUBECONFIG_B64 }}

  deploy-prod:
    name: Deploy to K8s (PROD)
    runs-on: ubuntu-latest
    needs: [docker-and-scan, prod-approval]
    if: ${{ env.DEPLOY_TO_K8S == 'true' && env.BUILD_PROFILE == 'prod' }}
    steps:
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ secrets.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
      - name: Update kubeconfig (EKS)
        run: aws eks update-kubeconfig --name "${{ secrets.EKS_CLUSTER_NAME }}" --region "${{ secrets.AWS_REGION }}"
      - name: Rollout image
        run: |
          kubectl -n default set image deployment/yourapp-deployment \
            yourapp-deployment=${ARTIFACTORY_REGISTRY}/${DOCKER_REPO}:${IMAGE_TAG}
          kubectl -n default rollout status deployment/yourapp-deployment --timeout=180s

  notify:
    name: Email Notifications
    runs-on: ubuntu-latest
    needs:
      - build-test
      - docker-and-scan
      - deploy-nonprod
      - deploy-prod
    if: always()
    steps:
      - name: Compose subject/body (SUCCESS)
        if: ${{ success() }}
        run: |
          echo "subject=SUCCESS: ${GITHUB_WORKFLOW} #${GITHUB_RUN_NUMBER} (${BUILD_PROFILE})" >> $GITHUB_ENV
          echo "body=<h3>✅ Build Succeeded</h3><p>Image: ${ARTIFACTORY_REGISTRY}/${DOCKER_REPO}:${IMAGE_TAG}</p><p>Run: ${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}</p>" >> $GITHUB_ENV
      - name: Compose subject/body (FAILURE)
        if: ${{ failure() }}
        run: |
          echo "subject=FAILED: ${GITHUB_WORKFLOW} #${GITHUB_RUN_NUMBER} (${BUILD_PROFILE})" >> $GITHUB_ENV
          echo "body=<h3>❌ Build/Deployment Failed</h3><p>Check logs: ${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}</p>" >> $GITHUB_ENV
      - name: Compose subject/body (CANCELLED)
        if: ${{ cancelled() }}
        run: |
          echo "subject=ABORTED: ${GITHUB_WORKFLOW} #${GITHUB_RUN_NUMBER} (${BUILD_PROFILE})" >> $GITHUB_ENV
          echo "body=<h3>⚠️ Workflow Cancelled</h3><p>Most likely the PROD approval timed out or was rejected.</p>" >> $GITHUB_ENV

      - name: Send Email
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.SMTP_SERVER }}
          server_port: ${{ secrets.SMTP_PORT }}
          username: ${{ secrets.SMTP_USERNAME }}
          password: ${{ secrets.SMTP_PASSWORD }}
          subject: ${{ env.subject }}
          to: ${{ env.MAIL_TO }}
          from: ${{ env.MAIL_FROM }}
          content_type: text/html
          body: ${{ env.body }}
